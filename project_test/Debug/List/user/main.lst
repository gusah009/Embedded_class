###############################################################################
#
# IAR ANSI C/C++ Compiler V9.10.2.313/W64 for ARM         06/Dec/2021  21:54:12
# Copyright 1999-2021 IAR Systems AB.
#
#    Cpu mode                 =  thumb
#    Endian                   =  little
#    Source file              =  C:\embed_exp\project_test\user\main.c
#    Command line             =
#        -f C:\embed_exp\project_test\Debug\Obj\user\main.o.rsp
#        (C:\embed_exp\project_test\user\main.c -D USE_STDPERIPH_DRIVER -D
#        STM32F10X_CL -lC C:\embed_exp\project_test\Debug\List\user -o
#        C:\embed_exp\project_test\Debug\Obj\user --no_cse --no_unroll
#        --no_inline --no_code_motion --no_tbaa --no_clustering --no_scheduling
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\inc\c\DLib_Config_Normal.h" -I
#        C:\embed_exp\project_test\libraries\CMSIS\DeviceSupport\ -I
#        C:\embed_exp\project_test\libraries\CMSIS\DeviceSupport\Startup\ -I
#        C:\embed_exp\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\
#        -I
#        C:\embed_exp\project_test\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\
#        -I C:\embed_exp\project_test\user\ -I
#        C:\embed_exp\project_test\user\inc\ -I
#        C:\embed_exp\project_test\Libraries\LCD\ -I
#        C:\embed_exp\project_test\Libraries\LCD\ -Ol -I "C:\Program Files\IAR
#        Systems\Embedded Workbench 9.0\arm\CMSIS\Core\Include\\" -I
#        "C:\Program Files\IAR Systems\Embedded Workbench
#        9.0\arm\CMSIS\DSP\Include\\") --dependencies=n
#        C:\embed_exp\project_test\Debug\Obj\user\main.o.d
#    Locale                   =  C
#    List file                =
#        C:\embed_exp\project_test\Debug\List\user\main.lst
#    Object file              =
#        C:\embed_exp\project_test\Debug\Obj\user\main.o
#    Runtime model:              
#      __SystemLibrary        =  DLib
#      __dlib_file_descriptor =  0
#      __dlib_version         =  6
#      __iar_require _Printf     
#      __size_limit           =  32768|ARM.EW.LINKER
#
###############################################################################

C:\embed_exp\project_test\user\main.c
      1          #include <stdio.h>
      2          #include "stm32f10x.h"
      3          #include "core_cm3.h"
      4          #include "misc.h"
      5          #include "stm32f10x_gpio.h"
      6          #include "stm32f10x_rcc.h"
      7          #include "stm32f10x_usart.h"
      8          #include "stm32f10x_adc.h"
      9          #include "stm32f10x_dma.h"
     10          
     11          #define ARRAYSIZE 8 * 4
     12          #define ADC1_DR ((uint32_t)0x4001244C)

   \                                 In section .bss, align 4
     13          volatile uint16_t ADC_values[ARRAYSIZE];
   \                     ADC_values:
   \        0x0                      DS8 64

   \                                 In section .bss, align 4
     14          static volatile uint32_t __status = 0;
   \                     __status:
   \        0x0                      DS8 4
     15          
     16          // 4000보다 크면 흔들림, 200보다 작으면 안흔들림
     17          

   \                                 In section .data, align 2
     18          uint16_t value = 100;
   \                     value:
   \        0x0   0x0064             DC16 100
     19          
     20          /* function prototype */
     21          void RCC_Configure(void);
     22          void GPIO_Configure(void);
     23          void NVIC_Configure(void);
     24          
     25          //---------------------------------------------------------------------------------------------------
     26          
     27          // void RCC_Configure(void)
     28          // {
     29          //     /* Alternate Function IO clock enable */
     30          //     RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOC, ENABLE); // ADC1, port C RCC ENABLE
     31          //     RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
     32          //     // 나머지 LCD에 필요한 포트들은 lcd.c에서 활성화 된다.
     33          // }
     34          
     35          // void GPIO_Configure(void)
     36          // {
     37          //     GPIO_InitTypeDef GPIO_InitStructure;
     38          //     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2;
     39          //     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     40          //     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; // 아날로그 입력 설정
     41          //     GPIO_Init(GPIOC, &GPIO_InitStructure);        // C0포트 활성화, 조도센서를 PC0에 연결할 계획
     42          // }
     43          
     44          #define Cycles ADC_SampleTime_28Cycles5
     45          //#define Cycles ADC_SampleTime_41Cycles5
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void ADCInit(void)
     48          {
   \                     ADCInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB086             SUB      SP,SP,#+24
     49              //--Enable ADC1 and GPIOA--
     50              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 | RCC_APB2Periph_GPIOA, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0xF44F 0x7001      MOV      R0,#+516
   \        0xA   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     51              GPIO_InitTypeDef GPIO_InitStructure; //Variable used to setup the GPIO pins
     52              //==Configure ADC pins (PA0 -> Channel 0 to PA7 -> Channel 7) as analog inputs==
     53              GPIO_StructInit(&GPIO_InitStructure); // Reset init structure, if not it can cause issues...
   \        0xE   0x4668             MOV      R0,SP
   \       0x10   0x.... 0x....      BL       GPIO_StructInit
     54              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
   \       0x14   0x20FF             MOVS     R0,#+255
   \       0x16   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     55              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \       0x1A   0x2000             MOVS     R0,#+0
   \       0x1C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     56              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \       0x20   0x4669             MOV      R1,SP
   \       0x22   0x....             LDR.N    R0,??DataTable5
   \       0x24   0x.... 0x....      BL       GPIO_Init
     57          
     58              ADC_InitTypeDef ADC_InitStructure;
     59              //ADC1 configuration
     60          
     61              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \       0x28   0x2000             MOVS     R0,#+0
   \       0x2A   0x9001             STR      R0,[SP, #+4]
     62              //We will convert multiple channels
     63              ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \       0x2C   0x2001             MOVS     R0,#+1
   \       0x2E   0xF88D 0x0008      STRB     R0,[SP, #+8]
     64              //select continuous conversion mode
     65              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE; //!
   \       0x32   0x2001             MOVS     R0,#+1
   \       0x34   0xF88D 0x0009      STRB     R0,[SP, #+9]
     66              //select no external triggering
     67              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \       0x38   0xF45F 0x2060      MOVS     R0,#+917504
   \       0x3C   0x9003             STR      R0,[SP, #+12]
     68              //right 12-bit data alignment in ADC data register
     69              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \       0x3E   0x2000             MOVS     R0,#+0
   \       0x40   0x9004             STR      R0,[SP, #+16]
     70              //8 channels conversion
     71              ADC_InitStructure.ADC_NbrOfChannel = 8;
   \       0x42   0x2008             MOVS     R0,#+8
   \       0x44   0xF88D 0x0014      STRB     R0,[SP, #+20]
     72              //load structure values to control and status registers
     73              ADC_Init(ADC1, &ADC_InitStructure);
   \       0x48   0xA901             ADD      R1,SP,#+4
   \       0x4A   0x....             LDR.N    R0,??DataTable5_1
   \       0x4C   0x.... 0x....      BL       ADC_Init
     74              //wake up temperature sensor
     75              //ADC_TempSensorVrefintCmd(ENABLE);
     76              //configure each channel
     77              ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, Cycles);
   \       0x50   0x2303             MOVS     R3,#+3
   \       0x52   0x2201             MOVS     R2,#+1
   \       0x54   0x2100             MOVS     R1,#+0
   \       0x56   0x....             LDR.N    R0,??DataTable5_1
   \       0x58   0x.... 0x....      BL       ADC_RegularChannelConfig
     78              ADC_RegularChannelConfig(ADC1, ADC_Channel_1, 2, Cycles);
   \       0x5C   0x2303             MOVS     R3,#+3
   \       0x5E   0x2202             MOVS     R2,#+2
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x....             LDR.N    R0,??DataTable5_1
   \       0x64   0x.... 0x....      BL       ADC_RegularChannelConfig
     79              ADC_RegularChannelConfig(ADC1, ADC_Channel_2, 3, Cycles);
   \       0x68   0x2303             MOVS     R3,#+3
   \       0x6A   0x2203             MOVS     R2,#+3
   \       0x6C   0x2102             MOVS     R1,#+2
   \       0x6E   0x....             LDR.N    R0,??DataTable5_1
   \       0x70   0x.... 0x....      BL       ADC_RegularChannelConfig
     80              ADC_RegularChannelConfig(ADC1, ADC_Channel_3, 4, Cycles);
   \       0x74   0x2303             MOVS     R3,#+3
   \       0x76   0x2204             MOVS     R2,#+4
   \       0x78   0x2103             MOVS     R1,#+3
   \       0x7A   0x....             LDR.N    R0,??DataTable5_1
   \       0x7C   0x.... 0x....      BL       ADC_RegularChannelConfig
     81              ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 5, Cycles);
   \       0x80   0x2303             MOVS     R3,#+3
   \       0x82   0x2205             MOVS     R2,#+5
   \       0x84   0x2104             MOVS     R1,#+4
   \       0x86   0x....             LDR.N    R0,??DataTable5_1
   \       0x88   0x.... 0x....      BL       ADC_RegularChannelConfig
     82              ADC_RegularChannelConfig(ADC1, ADC_Channel_5, 6, Cycles);
   \       0x8C   0x2303             MOVS     R3,#+3
   \       0x8E   0x2206             MOVS     R2,#+6
   \       0x90   0x2105             MOVS     R1,#+5
   \       0x92   0x....             LDR.N    R0,??DataTable5_1
   \       0x94   0x.... 0x....      BL       ADC_RegularChannelConfig
     83              ADC_RegularChannelConfig(ADC1, ADC_Channel_6, 7, Cycles);
   \       0x98   0x2303             MOVS     R3,#+3
   \       0x9A   0x2207             MOVS     R2,#+7
   \       0x9C   0x2106             MOVS     R1,#+6
   \       0x9E   0x....             LDR.N    R0,??DataTable5_1
   \       0xA0   0x.... 0x....      BL       ADC_RegularChannelConfig
     84              ADC_RegularChannelConfig(ADC1, ADC_Channel_7, 8, Cycles);
   \       0xA4   0x2303             MOVS     R3,#+3
   \       0xA6   0x2208             MOVS     R2,#+8
   \       0xA8   0x2107             MOVS     R1,#+7
   \       0xAA   0x....             LDR.N    R0,??DataTable5_1
   \       0xAC   0x.... 0x....      BL       ADC_RegularChannelConfig
     85              //Enable ADC1
     86              ADC_Cmd(ADC1, ENABLE);
   \       0xB0   0x2101             MOVS     R1,#+1
   \       0xB2   0x....             LDR.N    R0,??DataTable5_1
   \       0xB4   0x.... 0x....      BL       ADC_Cmd
     87              //enable DMA for ADC
     88              ADC_DMACmd(ADC1, ENABLE);
   \       0xB8   0x2101             MOVS     R1,#+1
   \       0xBA   0x....             LDR.N    R0,??DataTable5_1
   \       0xBC   0x.... 0x....      BL       ADC_DMACmd
     89              //Enable ADC1 reset calibration register
     90              ADC_ResetCalibration(ADC1);
   \       0xC0   0x....             LDR.N    R0,??DataTable5_1
   \       0xC2   0x.... 0x....      BL       ADC_ResetCalibration
     91              //Check the end of ADC1 reset calibration register
     92              while (ADC_GetResetCalibrationStatus(ADC1))
   \                     ??ADCInit_0: (+1)
   \       0xC6   0x....             LDR.N    R0,??DataTable5_1
   \       0xC8   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \       0xCC   0x2800             CMP      R0,#+0
   \       0xCE   0xD1FA             BNE.N    ??ADCInit_0
     93                  ;
     94              //Start ADC1 calibration
     95              ADC_StartCalibration(ADC1);
   \       0xD0   0x....             LDR.N    R0,??DataTable5_1
   \       0xD2   0x.... 0x....      BL       ADC_StartCalibration
     96              //Check the end of ADC1 calibration
     97              while (ADC_GetCalibrationStatus(ADC1))
   \                     ??ADCInit_1: (+1)
   \       0xD6   0x....             LDR.N    R0,??DataTable5_1
   \       0xD8   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \       0xDC   0x2800             CMP      R0,#+0
   \       0xDE   0xD1FA             BNE.N    ??ADCInit_1
     98                  ;
     99          }
   \       0xE0   0xB007             ADD      SP,SP,#+28
   \       0xE2   0xBD00             POP      {PC}
    100          

   \                                 In section .text, align 2, keep-with-next
    101          void DMAInit(void)
    102          {
   \                     DMAInit: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
   \        0x2   0xB08C             SUB      SP,SP,#+48
    103              DMA_InitTypeDef DMA_InitStructure;
    104              NVIC_InitTypeDef NVIC_InitStructure;
    105              //enable DMA1 clock
    106              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x2001             MOVS     R0,#+1
   \        0x8   0x.... 0x....      BL       RCC_AHBPeriphClockCmd
    107              //create DMA structure
    108              //reset DMA1 channe1 to default values;
    109              DMA_DeInit(DMA1_Channel1);
   \        0xC   0x....             LDR.N    R0,??DataTable5_2
   \        0xE   0x.... 0x....      BL       DMA_DeInit
    110              //channel will be used for memory to memory transfer
    111              DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x900B             STR      R0,[SP, #+44]
    112              //setting normal mode (non circular)
    113              DMA_InitStructure.DMA_Mode = DMA_Mode_Circular; //DMA_Mode_Normal;
   \       0x16   0x2020             MOVS     R0,#+32
   \       0x18   0x9009             STR      R0,[SP, #+36]
    114              //medium priority
    115              DMA_InitStructure.DMA_Priority = DMA_Priority_High;
   \       0x1A   0xF44F 0x5000      MOV      R0,#+8192
   \       0x1E   0x900A             STR      R0,[SP, #+40]
    116              //source and destination data size word=32bit
    117              DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
   \       0x20   0xF44F 0x7080      MOV      R0,#+256
   \       0x24   0x9007             STR      R0,[SP, #+28]
    118              DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
   \       0x26   0xF44F 0x6080      MOV      R0,#+1024
   \       0x2A   0x9008             STR      R0,[SP, #+32]
    119              //automatic memory destination increment enable.
    120              DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   \       0x2C   0x2080             MOVS     R0,#+128
   \       0x2E   0x9006             STR      R0,[SP, #+24]
    121              //source address increment disable
    122              DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \       0x30   0x2000             MOVS     R0,#+0
   \       0x32   0x9005             STR      R0,[SP, #+20]
    123              //Location assigned to peripheral register will be source
    124              DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
   \       0x34   0x2000             MOVS     R0,#+0
   \       0x36   0x9003             STR      R0,[SP, #+12]
    125              //chunk of data to be transfered
    126              DMA_InitStructure.DMA_BufferSize = ARRAYSIZE;
   \       0x38   0x2020             MOVS     R0,#+32
   \       0x3A   0x9004             STR      R0,[SP, #+16]
    127              //source and destination start addresses
    128              DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC1_DR;
   \       0x3C   0x....             LDR.N    R0,??DataTable5_3
   \       0x3E   0x9001             STR      R0,[SP, #+4]
    129              DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)ADC_values;
   \       0x40   0x....             LDR.N    R0,??DataTable5_4
   \       0x42   0x9002             STR      R0,[SP, #+8]
    130              //send values to DMA registers
    131              DMA_Init(DMA1_Channel1, &DMA_InitStructure);
   \       0x44   0xA901             ADD      R1,SP,#+4
   \       0x46   0x....             LDR.N    R0,??DataTable5_2
   \       0x48   0x.... 0x....      BL       DMA_Init
    132              // Enable DMA1 Channel Transfer Complete interrupt
    133              DMA_ITConfig(DMA1_Channel1, DMA_IT_TC, ENABLE);
   \       0x4C   0x2201             MOVS     R2,#+1
   \       0x4E   0x2102             MOVS     R1,#+2
   \       0x50   0x....             LDR.N    R0,??DataTable5_2
   \       0x52   0x.... 0x....      BL       DMA_ITConfig
    134              DMA_Cmd(DMA1_Channel1, ENABLE); //Enable the DMA1 - Channel1
   \       0x56   0x2101             MOVS     R1,#+1
   \       0x58   0x....             LDR.N    R0,??DataTable5_2
   \       0x5A   0x.... 0x....      BL       DMA_Cmd
    135          
    136              //Enable DMA1 channel IRQ Channel */
    137              NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel1_IRQn;
   \       0x5E   0x200B             MOVS     R0,#+11
   \       0x60   0xF88D 0x0000      STRB     R0,[SP, #+0]
    138              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
   \       0x64   0x2000             MOVS     R0,#+0
   \       0x66   0xF88D 0x0001      STRB     R0,[SP, #+1]
    139              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
   \       0x6A   0x2000             MOVS     R0,#+0
   \       0x6C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    140              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \       0x70   0x2001             MOVS     R0,#+1
   \       0x72   0xF88D 0x0003      STRB     R0,[SP, #+3]
    141              NVIC_Init(&NVIC_InitStructure);
   \       0x76   0x4668             MOV      R0,SP
   \       0x78   0x.... 0x....      BL       NVIC_Init
    142          }
   \       0x7C   0xB00D             ADD      SP,SP,#+52
   \       0x7E   0xBD00             POP      {PC}
    143          

   \                                 In section .text, align 2, keep-with-next
    144          void DMA1_Channel1_IRQHandler(void)
    145          {
   \                     DMA1_Channel1_IRQHandler: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    146              //Test on DMA1 Channel1 Transfer Complete interrupt
    147              if (DMA_GetITStatus(DMA1_IT_TC1))
   \        0x2   0x2002             MOVS     R0,#+2
   \        0x4   0x.... 0x....      BL       DMA_GetITStatus
   \        0x8   0x2800             CMP      R0,#+0
   \        0xA   0xD007             BEQ.N    ??DMA1_Channel1_IRQHandler_0
    148              {
    149                  DMA_ClearITPendingBit(DMA1_IT_TC1 | DMA1_IT_GL1);
   \        0xC   0x2003             MOVS     R0,#+3
   \        0xE   0x.... 0x....      BL       DMA_ClearITPendingBit
    150                  __status++;
   \       0x12   0x....             LDR.N    R0,??DataTable5_5
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x1C40             ADDS     R0,R0,#+1
   \       0x18   0x....             LDR.N    R1,??DataTable5_5
   \       0x1A   0x6008             STR      R0,[R1, #+0]
    151              }
    152          }
   \                     ??DMA1_Channel1_IRQHandler_0: (+1)
   \       0x1C   0xBD01             POP      {R0,PC}
    153          

   \                                 In section .data, align 4
    154          int adc_view_flag = 1;
   \                     adc_view_flag:
   \        0x0   0x0000'0001        DC32 1

   \                                 In section .text, align 2, keep-with-next
    155          void dma_test_adc8ch(void)
    156          {
   \                     dma_test_adc8ch: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    157              if (!__status)
   \        0x2   0x....             LDR.N    R0,??DataTable5_5
   \        0x4   0x6800             LDR      R0,[R0, #+0]
   \        0x6   0x2800             CMP      R0,#+0
   \        0x8   0xD048             BEQ.N    ??dma_test_adc8ch_0
    158                  return;
    159          
    160              uint8_t index;
    161              ADC_SoftwareStartConvCmd(ADC1, DISABLE);
   \                     ??dma_test_adc8ch_1: (+1)
   \        0xA   0x2100             MOVS     R1,#+0
   \        0xC   0x....             LDR.N    R0,??DataTable5_1
   \        0xE   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    162              if (adc_view_flag)
   \       0x12   0x....             LDR.N    R0,??DataTable5_6
   \       0x14   0x6800             LDR      R0,[R0, #+0]
   \       0x16   0x2800             CMP      R0,#+0
   \       0x18   0xD039             BEQ.N    ??dma_test_adc8ch_2
    163              {
    164                  for (index = 0; index < 8; index++)
   \       0x1A   0x2400             MOVS     R4,#+0
   \       0x1C   0xE030             B.N      ??dma_test_adc8ch_3
    165                  {
    166                      printf("%d ADC value on ch%d = %d ,%d\r\n",
    167                             __status, index, (uint16_t)((ADC_values[index] + ADC_values[index + 8] + ADC_values[index + 16] + ADC_values[index + 24]) / 4), ADC_values[index]);
   \                     ??dma_test_adc8ch_4: (+1)
   \       0x1E   0x....             LDR.N    R0,??DataTable5_4
   \       0x20   0x0021             MOVS     R1,R4
   \       0x22   0xB2C9             UXTB     R1,R1
   \       0x24   0xF830 0x0011      LDRH     R0,[R0, R1, LSL #+1]
   \       0x28   0x....             LDR.N    R1,??DataTable5_4
   \       0x2A   0x0022             MOVS     R2,R4
   \       0x2C   0xB2D2             UXTB     R2,R2
   \       0x2E   0xF831 0x1012      LDRH     R1,[R1, R2, LSL #+1]
   \       0x32   0x....             LDR.N    R2,??DataTable5_4
   \       0x34   0x0023             MOVS     R3,R4
   \       0x36   0xB2DB             UXTB     R3,R3
   \       0x38   0xEB02 0x0243      ADD      R2,R2,R3, LSL #+1
   \       0x3C   0x8A12             LDRH     R2,[R2, #+16]
   \       0x3E   0x....             LDR.N    R3,??DataTable5_4
   \       0x40   0x0025             MOVS     R5,R4
   \       0x42   0xB2ED             UXTB     R5,R5
   \       0x44   0xEB03 0x0345      ADD      R3,R3,R5, LSL #+1
   \       0x48   0x8C1B             LDRH     R3,[R3, #+32]
   \       0x4A   0x....             LDR.N    R5,??DataTable5_4
   \       0x4C   0x0026             MOVS     R6,R4
   \       0x4E   0xB2F6             UXTB     R6,R6
   \       0x50   0xEB05 0x0546      ADD      R5,R5,R6, LSL #+1
   \       0x54   0x8E2D             LDRH     R5,[R5, #+48]
   \       0x56   0xB280             UXTH     R0,R0
   \       0x58   0x9000             STR      R0,[SP, #+0]
   \       0x5A   0xB289             UXTH     R1,R1
   \       0x5C   0xB292             UXTH     R2,R2
   \       0x5E   0x1851             ADDS     R1,R2,R1
   \       0x60   0xB29B             UXTH     R3,R3
   \       0x62   0x1859             ADDS     R1,R3,R1
   \       0x64   0xB2AD             UXTH     R5,R5
   \       0x66   0x1869             ADDS     R1,R5,R1
   \       0x68   0x2004             MOVS     R0,#+4
   \       0x6A   0xFB91 0xF3F0      SDIV     R3,R1,R0
   \       0x6E   0xB29B             UXTH     R3,R3
   \       0x70   0x0022             MOVS     R2,R4
   \       0x72   0xB2D2             UXTB     R2,R2
   \       0x74   0x....             LDR.N    R0,??DataTable5_5
   \       0x76   0x6801             LDR      R1,[R0, #+0]
   \       0x78   0x....             LDR.N    R0,??DataTable5_7
   \       0x7A   0x.... 0x....      BL       printf
    168                  }
   \       0x7E   0x1C64             ADDS     R4,R4,#+1
   \                     ??dma_test_adc8ch_3: (+1)
   \       0x80   0x0020             MOVS     R0,R4
   \       0x82   0xB2C0             UXTB     R0,R0
   \       0x84   0x2808             CMP      R0,#+8
   \       0x86   0xDBCA             BLT.N    ??dma_test_adc8ch_4
    169                  printf("=========================\n\r");
   \       0x88   0x....             LDR.N    R0,??DataTable5_8
   \       0x8A   0x.... 0x....      BL       printf
    170              }
    171              __status = 0;
   \                     ??dma_test_adc8ch_2: (+1)
   \       0x8E   0x2000             MOVS     R0,#+0
   \       0x90   0x....             LDR.N    R1,??DataTable5_5
   \       0x92   0x6008             STR      R0,[R1, #+0]
    172              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \       0x94   0x2101             MOVS     R1,#+1
   \       0x96   0x....             LDR.N    R0,??DataTable5_1
   \       0x98   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    173          }
   \                     ??dma_test_adc8ch_0: (+1)
   \       0x9C   0xBD73             POP      {R0,R1,R4-R6,PC}
    174          
    175          // void ADC1_Configure(void)
    176          // {
    177          //     // Analog to Digital Converter
    178          //     ADC_InitTypeDef ADC_InitStruct;
    179          
    180          //     //ADC_StructInit(&ADC_InitStruct);
    181          //     ADC_InitStruct.ADC_Mode = ADC_Mode_Independent;                  // slave-master가 없는 독립 ADC
    182          //     ADC_InitStruct.ADC_ScanConvMode = DISABLE;                       // 단일채널이므로 비활성화
    183          //     ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;                  // 한 번의 트리거로 한 채널의 샘플링 시행
    184          //     ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // 외부 입력핀에 의한 트리거 비활성화
    185          //     ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;              // Default
    186          //     ADC_InitStruct.ADC_NbrOfChannel = 1;                             // 채널은 하나
    187          
    188          //     ADC_Init(ADC1, &ADC_InitStruct); // 위 설정을 ADC1에 적용
    189          
    190          //     ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_28Cycles5); // 채널 우선순위 설정, 10채널 단독사용
    191          
    192          //     // ADC_ITConfig(ADC1,ADC_IT_EOC,ENABLE); // 무분별한 핸들러 호출 방지를 위해 주석처리
    193          
    194          //     ADC_Cmd(ADC1, ENABLE); // ADC1 활성화
    195          
    196          //     //Calibration reset & start
    197          //     ADC_ResetCalibration(ADC1);
    198          
    199          //     while (ADC_GetResetCalibrationStatus(ADC1))
    200          //         ;
    201          
    202          //     ADC_StartCalibration(ADC1);
    203          
    204          //     while (ADC_GetCalibrationStatus(ADC1))
    205          //         ;
    206          
    207          //     ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    208          // }
    209          
    210          // void ADC_Configure(void)
    211          // {
    212          //     ADC1_Configure();
    213          //     ADC2_Configure();
    214          // }
    215          
    216          // void NVIC_Configure(void)
    217          // {
    218          
    219          //     NVIC_InitTypeDef NVIC_InitStructure;
    220          
    221          //     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    222          
    223          //     NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn; // ADC IRQ 인터럽트 활성화
    224          //     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    225          //     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    226          //     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    227          //     NVIC_Init(&NVIC_InitStructure);
    228          // }
    229          
    230          // void ADC1_2_IRQHandler(void)
    231          // {
    232          //     // printf("Handle\n");
    233          //     if (ADC_GetITStatus(ADC1, ADC_IT_EOC) != RESET)
    234          //     {                                         // End Of Conversion, ADC변환이 끝났을때,
    235          //         value = ADC_GetConversionValue(ADC1); // value에 조도센서 값 입력
    236          //         printf("%d\n", value);
    237          //         ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
    238          //     }
    239          // }
    240          

   \                                 In section .text, align 2, keep-with-next
    241          void delay()
    242          {
    243              for (int i = 0; i < 1000000; i++)
   \                     delay: (+1)
   \        0x0   0x2000             MOVS     R0,#+0
   \        0x2   0xE000             B.N      ??delay_0
    244              {
    245                  continue;
   \                     ??delay_1: (+1)
   \        0x4   0x1C40             ADDS     R0,R0,#+1
   \                     ??delay_0: (+1)
   \        0x6   0x....             LDR.N    R1,??DataTable5_9
   \        0x8   0x4288             CMP      R0,R1
   \        0xA   0xDBFB             BLT.N    ??delay_1
    246              }
    247          }
   \        0xC   0x4770             BX       LR
    248          

   \                                 In section .text, align 2, keep-with-next
    249          int main(void)
    250          {
   \                     main: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    251          
    252              SystemInit();
   \        0x2   0x.... 0x....      BL       SystemInit
    253              // RCC_Configure();
    254              // GPIO_Configure();
    255              // ADC_Configure();
    256              // NVIC_Configure();
    257          
    258              ADCInit();
   \        0x6   0x.... 0x....      BL       ADCInit
    259                DMAInit();
   \        0xA   0x.... 0x....      BL       DMAInit
    260              //-----------------
    261          
    262              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \        0xE   0x2101             MOVS     R1,#+1
   \       0x10   0x....             LDR.N    R0,??DataTable5_1
   \       0x12   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    263              // ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE); // ADC 변환이 끝났을때 인터럽트 발생
    264              while (1)
    265              {
    266                  dma_test_adc8ch();
   \                     ??main_0: (+1)
   \       0x16   0x.... 0x....      BL       dma_test_adc8ch
    267                  delay();
   \       0x1A   0x.... 0x....      BL       delay
   \       0x1E   0xE7FA             B.N      ??main_0
    268              }
    269              return 0;
                     ^
Warning[Pe111]: statement is unreachable

              printf("%d ADC value on ch%d = %d ,%d\r\n",
              ^
"C:\embed_exp\project_test\user\main.c",166  Warning[Pa082]: undefined
          behavior: the order of volatile accesses is undefined in this
          statement
    270          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \        0x0   0x4001'0800        DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \        0x0   0x4002'0008        DC32     0x40020008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \        0x0   0x4001'244C        DC32     0x4001244c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \        0x0   0x....'....        DC32     ADC_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \        0x0   0x....'....        DC32     __status

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \        0x0   0x....'....        DC32     adc_view_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \        0x0   0x....'....        DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \        0x0   0x....'....        DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \        0x0   0x000F'4240        DC32     0xf4240

   \                                 In section .rodata, align 4
   \                     ?_0:
   \        0x0   0x25 0x64          DC8 "%d ADC value on ch%d = %d ,%d\015\012"

   \              0x20 0x41    

   \              0x44 0x43    

   \              0x20 0x76    

   \              0x61 0x6C    

   \              0x75 0x65    

   \              0x20 0x6F    

   \              0x6E 0x20    

   \              0x63 0x68    

   \              0x25 0x64    

   \              0x20 0x3D    

   \              0x20 0x25    

   \              0x64 0x20    

   \              0x2C 0x25    

   \              0x64 0x0D    

   \              0x0A 0x00

   \                                 In section .rodata, align 4
   \                     ?_1:
   \        0x0   0x3D 0x3D          DC8 "=========================\012\015"

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x3D    

   \              0x3D 0x0A    

   \              0x0D 0x00

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   ADCInit
        32   -> ADC_Cmd
        32   -> ADC_DMACmd
        32   -> ADC_GetCalibrationStatus
        32   -> ADC_GetResetCalibrationStatus
        32   -> ADC_Init
        32   -> ADC_RegularChannelConfig
        32   -> ADC_ResetCalibration
        32   -> ADC_StartCalibration
        32   -> GPIO_Init
        32   -> GPIO_StructInit
        32   -> RCC_APB2PeriphClockCmd
       8   DMA1_Channel1_IRQHandler
         8   -> DMA_ClearITPendingBit
         8   -> DMA_GetITStatus
      56   DMAInit
        56   -> DMA_Cmd
        56   -> DMA_DeInit
        56   -> DMA_ITConfig
        56   -> DMA_Init
        56   -> NVIC_Init
        56   -> RCC_AHBPeriphClockCmd
       0   delay
      24   dma_test_adc8ch
        24   -> ADC_SoftwareStartConvCmd
        24   -> printf
       8   main
         8   -> ADCInit
         8   -> ADC_SoftwareStartConvCmd
         8   -> DMAInit
         8   -> SystemInit
         8   -> delay
         8   -> dma_test_adc8ch


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      32  ?_0
      28  ?_1
     228  ADCInit
      64  ADC_values
      30  DMA1_Channel1_IRQHandler
     128  DMAInit
       4  __status
       4  adc_view_flag
      14  delay
     158  dma_test_adc8ch
      32  main
       2  value

 
  68 bytes in section .bss
   6 bytes in section .data
  60 bytes in section .rodata
 630 bytes in section .text
 
 630 bytes of CODE  memory
  60 bytes of CONST memory
  74 bytes of DATA  memory

Errors: none
Warnings: 2
